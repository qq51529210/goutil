package main

import (
	"fmt"
	"log"
	"net"
	"os"
	"time"

	"github.com/alfg/mp4"
	"github.com/pion/rtp"
	"github.com/pion/rtp/codecs"
)

func main() {
	// 建立与服务器的UDP连接
	serverAddr, err := net.ResolveUDPAddr("udp", "localhost:8000")
	if err != nil {
		log.Fatal(err)
	}

	conn, err := net.DialUDP("udp", nil, serverAddr)
	if err != nil {
		log.Fatal(err)
	}
	defer conn.Close()

	// 打开本地的MP4文件
	file, err := os.Open("example.mp4")
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	// 创建RTP传输器
	rtpTransceiver, err := rtp.NewTransceiver(conn, &rtp.TransceiverConfig{
		PayloadType: 96,
	})
	if err != nil {
		log.Fatal(err)
	}

	// 创建H264解码器
	h264Decoder := &codecs.H264Decoder{}

	// 创建Sample Builder
	sampleBuilder := &codecs.SampleBuilder{
		Tran: rtpTransceiver,
	}

	// 创建MP4解析器
	mp4File, err := mp4.Open("example.mp4")
	if err != nil {
		log.Fatal(err)
	}
	defer mp4File.Close()

	// 遍历所有轨道
	for _, track := range mp4File.Tracks {
		// 只处理视频轨道
		if track.Type() != mp4.Mp4v {
			continue
		}

		// 获取视频轨道的时间刻度和帧率
		timeScale := float64(track.TimeScale())
		frameRate := float64(track.FrameRate())

		// 遍历所有样本
		for _, sample := range track.Samples {
			// 解码样本数据
			nalus, err := h264Decoder.Decode(sample.Data)
			if err != nil {
				log.Fatal(err)
			}

			// 将NALU数据封装为RTP数据包并发送
			for _, nalu := range nalus {
				rtpPacket := &rtp.Packet{
					Header: rtp.Header{
						Version:        2,
						Marker:         0,
						SequenceNumber: rtpTransceiver.GetNextSequenceNumber(),
						Timestamp:      uint32(float64(sample.Index) * (timeScale / frameRate)),
						SSRC:           12345,
					},
					Payload: nalu,
				}

				err := sampleBuilder.Push(rtpPacket)
				if err != nil {
					log.Fatal(err)
				}
			}

			// 模拟实时推流延迟
			time.Sleep(time.Second / time.Duration(frameRate))
		}
	}

	fmt.Println("推流完成")
}